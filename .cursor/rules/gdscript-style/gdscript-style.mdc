---
title: GDScript & Godot 4 Best Practices
description: Leia esta regra quando for escrever, revisar ou padronizar scripts em GDScript para o projeto Godot 4. Use-a ao criar novos scripts, revisar nomes, estrutura, comentários, uso de sinais, exportações, ou ao garantir aderência às melhores práticas de codificação Godot.
alwaysApply: false
---

# GDScript & Godot 4 Best Practices

- Use snake_case for variable and function names.
- Use PascalCase for class names.
- Each script should define a single class or component e ter `class_name` quando for reutilizável.
- Prefer composition (nodes/scenes) over inheritance quando possível.
- Use Godot's signal system para comunicação desacoplada; sempre tipar parâmetros de callbacks.
- Use `@export` para variáveis expostas no editor e inclua o tipo: `@export var speed: float = 200.0`.
- Use `@onready` para referências a nós que requerem a árvore de cena; tipar as referências.
- Mantenha scripts focados e idealmente < 200 linhas.
- Documente funções complexas com docstrings concisas (o "porquê").
- Use tipos nativos (Vector2, Color, etc.) por clareza e performance.
- Evite hardcode de paths; prefira `preload()` para assets estáticos e `load()` para dinâmicos.
- `_ready()` para inicialização, `_process(delta)` para lógica por frame, `_physics_process(delta)` para física.
- Prefira sinais a polling para lógica orientada a eventos.
- Use grupos para gerenciar coleções de nós (ex.: `Player`, `Enemies`).
- Conexão de sinais: centralize em um método dedicado (ex.: `_setup_signals_connections()`), chame em `_ready()`.
- Ordem sugerida no script: constantes, exports, onready, signals, variáveis, lifecycle callbacks, sinais, API pública, helpers privados.
- Nomeie callbacks de sinais como `_on_<node>_<signal>()`.
- Evite abreviações em nomes; seja descritivo.

## Example
```gdscript
extends Node2D

@export var speed: float = 200.0
@onready var sprite: Sprite2D = $Sprite2D

func _ready():
    print("Node ready!")

func _process(delta):
    position.x += speed * delta
```

## Padrões específicos observados no projeto
- Componentes como `HealthComponent`, `StatsComponent`, `LevelComponent` devem expor sinais claros (`died`, `health_changed`, `level_changed`) e manter estado encapsulado com getters/setters quando necessário.
- Callbacks de morte devem desativar física/lógica e acionar animações antes de `queue_free()`.
- Use `all`/`any` de `Array` com funções puras para verificações globais (ex.: verificar todos jogadores mortos) e tipagem explícita do array: `as Array[Player]`.
